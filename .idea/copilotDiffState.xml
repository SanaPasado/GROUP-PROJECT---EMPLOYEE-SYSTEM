<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/attendance/views.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/attendance/views.py" />
              <option name="originalContent" value="from datetime import date&#10;from django.contrib import messages&#10;from django.contrib.auth.decorators import login_required, user_passes_test&#10;from django.shortcuts import render, redirect, get_object_or_404&#10;from django.utils import timezone&#10;from django.utils.decorators import method_decorator&#10;from django.views.generic import ListView, DetailView&#10;from django.db.models import Q&#10;&#10;from .models import Attendance&#10;&#10;# Helper: staff check&#10;def is_staff(user):&#10;    return user.is_staff&#10;&#10;&#10;@login_required&#10;def my_attendance(request):&#10;    today = timezone.now().date()&#10;    user = request.user&#10;&#10;    try:&#10;        record = Attendance.objects.get(employee=user, date=today)&#10;        has_timed_in = bool(record.time_in)&#10;        has_timed_out = bool(record.time_out)&#10;    except Attendance.DoesNotExist:&#10;        record = None&#10;        has_timed_in = False&#10;        has_timed_out = False&#10;&#10;    # The ordering is defined in the model's Meta&#10;    records = Attendance.objects.filter(employee=user)[:10]&#10;    if request.user.is_staff:&#10;        return redirect('attendance:attendance_list')&#10;    else:&#10;        return render(request, 'attendance/my_attendance.html', {&#10;            'has_timed_in': has_timed_in,&#10;            'has_timed_out': has_timed_out,&#10;            'records': records&#10;    })&#10;&#10;&#10;@login_required&#10;def record_time(request):&#10;    if request.method == 'POST':&#10;        action = request.POST.get('action')&#10;        user = request.user&#10;        today = timezone.now().date()&#10;&#10;        if action == 'in':&#10;            if Attendance.objects.filter(employee=user, date=today).exists():&#10;                messages.error(request, &quot;You have already timed in today.&quot;)&#10;            else:&#10;                # Use timezone.now() directly in create&#10;                Attendance.objects.create(&#10;                    employee=user,&#10;                    date=today,&#10;                    time_in=timezone.now()&#10;                )&#10;                messages.success(request, &quot;Time In recorded successfully.&quot;)&#10;&#10;        elif action == 'out':&#10;            try:&#10;                attendance = Attendance.objects.get(employee=user, date=today)&#10;                if attendance.time_out:&#10;                    messages.error(request, &quot;You have already timed out today.&quot;)&#10;                elif not attendance.time_in:&#10;                    messages.error(request, &quot;You must time in before timing out.&quot;)&#10;                else:&#10;                    # Use update instead of save to avoid potential issues&#10;                    Attendance.objects.filter(employee=user, date=today).update(&#10;                        time_out=timezone.now()&#10;                    )&#10;                    messages.success(request, &quot;Time Out recorded successfully.&quot;)&#10;            except Attendance.DoesNotExist:&#10;                messages.error(request, &quot;You haven't timed in yet.&quot;)&#10;&#10;    return redirect('attendance:my-attendance')&#10;&#10;&#10;# Staff-only list view&#10;@method_decorator([login_required, user_passes_test(is_staff)], name='dispatch')&#10;class AttendanceListView(ListView):&#10;    model = Attendance&#10;    template_name = 'attendance/attendance_list.html'&#10;    context_object_name = 'attendance_records'&#10;    paginate_by = 20&#10;&#10;    def get_queryset(self):&#10;        # The ordering is now handled in the model's Meta class&#10;        queryset = Attendance.objects.select_related('employee')&#10;        query = self.request.GET.get('q')&#10;        if query:&#10;            queryset = queryset.filter(&#10;                Q(employee__first_name__icontains=query) |&#10;                Q(employee__last_name__icontains=query) |&#10;                Q(employee__department__icontains=query) |&#10;                Q(employee__position__icontains=query)&#10;            )&#10;        return queryset&#10;&#10;&#10;# Staff-only detail view&#10;@method_decorator([login_required, user_passes_test(is_staff)], name='dispatch')&#10;class AttendanceDetailView(DetailView):&#10;    model = Attendance&#10;    template_name = 'attendance/attendance_detail.html'&#10;    context_object_name = 'record'&#10;" />
              <option name="updatedContent" value="from datetime import date&#10;from django.contrib import messages&#10;from django.contrib.auth.decorators import login_required, user_passes_test&#10;from django.shortcuts import render, redirect, get_object_or_404&#10;from django.utils import timezone&#10;from django.utils.decorators import method_decorator&#10;from django.views.generic import ListView, DetailView&#10;from django.db.models import Q&#10;&#10;from .models import Attendance&#10;&#10;# Helper: staff check&#10;def is_staff(user):&#10;    return user.is_staff&#10;&#10;&#10;@login_required&#10;def my_attendance(request):&#10;    today = timezone.now().date()&#10;    user = request.user&#10;&#10;    try:&#10;        record = Attendance.objects.get(employee=user, date=today)&#10;        has_timed_in = bool(record.time_in)&#10;        has_timed_out = bool(record.time_out)&#10;    except Attendance.DoesNotExist:&#10;        record = None&#10;        has_timed_in = False&#10;        has_timed_out = False&#10;&#10;    # The ordering is defined in the model's Meta&#10;    records = Attendance.objects.filter(employee=user)[:10]&#10;    if request.user.is_staff:&#10;        return redirect('attendance:attendance_list')&#10;    else:&#10;        return render(request, 'attendance/my_attendance.html', {&#10;            'has_timed_in': has_timed_in,&#10;            'has_timed_out': has_timed_out,&#10;            'records': records&#10;    })&#10;&#10;&#10;@login_required&#10;def record_time(request):&#10;    if request.method == 'POST':&#10;        action = request.POST.get('action')&#10;        user = request.user&#10;        today = timezone.now().date()&#10;        current_time = timezone.now()  # Get current timezone-aware datetime&#10;&#10;        if action == 'in':&#10;            if Attendance.objects.filter(employee=user, date=today).exists():&#10;                messages.error(request, &quot;You have already timed in today.&quot;)&#10;            else:&#10;                # Create with timezone-aware datetime&#10;                Attendance.objects.create(&#10;                    employee=user, &#10;                    date=today, &#10;                    time_in=current_time&#10;                )&#10;                messages.success(request, &quot;Time In recorded successfully.&quot;)&#10;&#10;        elif action == 'out':&#10;            try:&#10;                attendance = Attendance.objects.get(employee=user, date=today)&#10;                if attendance.time_out:&#10;                    messages.error(request, &quot;You have already timed out today.&quot;)&#10;                elif not attendance.time_in:&#10;                    messages.error(request, &quot;You must time in before timing out.&quot;)&#10;                else:&#10;                    # Update with timezone-aware datetime&#10;                    attendance.time_out = current_time&#10;                    attendance.save()  # Use save() instead of update()&#10;                    messages.success(request, &quot;Time Out recorded successfully.&quot;)&#10;            except Attendance.DoesNotExist:&#10;                messages.error(request, &quot;You haven't timed in yet.&quot;)&#10;&#10;    return redirect('attendance:my-attendance')&#10;&#10;&#10;# Staff-only list view&#10;@method_decorator([login_required, user_passes_test(is_staff)], name='dispatch')&#10;class AttendanceListView(ListView):&#10;    model = Attendance&#10;    template_name = 'attendance/attendance_list.html'&#10;    context_object_name = 'attendance_records'&#10;    paginate_by = 20&#10;&#10;    def get_queryset(self):&#10;        # The ordering is now handled in the model's Meta class&#10;        queryset = Attendance.objects.select_related('employee')&#10;        query = self.request.GET.get('q')&#10;        if query:&#10;            queryset = queryset.filter(&#10;                Q(employee__first_name__icontains=query) |&#10;                Q(employee__last_name__icontains=query) |&#10;                Q(employee__department__icontains=query) |&#10;                Q(employee__position__icontains=query)&#10;            )&#10;        return queryset&#10;&#10;&#10;# Staff-only detail view&#10;@method_decorator([login_required, user_passes_test(is_staff)], name='dispatch')&#10;class AttendanceDetailView(DetailView):&#10;    model = Attendance&#10;    template_name = 'attendance/attendance_detail.html'&#10;    context_object_name = 'record'" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>